Aplikacja do gromadzenia i wizualizacji pomiarów temperatury.

Stack technologiczny
backend - Java 21
frontend - Angular 20.3.9
database - Postgres

Backend
Autoryzacja i uwierzytelnianie
Autoryzacja i uwierzytelnianie odbywa się z wykorzystaniem frameworka Spring Security, stosując JWT (JSON Web Token).
W ten sposób minimalizowane jest obciążenie serwera, nie musi on przechowywać sesji. Dzięki temu jest to rozwiązanie szybkie i skalowalne.
Obsługa uwierzytelniania i autoryzacji zrealizowana jest w klasach
JwtAuthenticationFilter – konfiguracja JWT
JwtUtil – metody pomocniczne JWT
SecurityConfig – konfiguracja zabezpieczeń

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
            .csrf(AbstractHttpConfigurer::disable)
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                    .requestMatchers("/api/auth/**").permitAll()
                    .requestMatchers(HttpMethod.GET, "/v3/api-docs/**", "/swagger-ui/**", "/api/series/**").permitAll()
                    .requestMatchers(HttpMethod.GET, "/api/measurements/**", "/api/series/**").permitAll()
                    .requestMatchers(HttpMethod.POST, "/api/measurements/**", "/api/series/**").hasRole("ADMIN")
                    .requestMatchers(HttpMethod.PUT, "/api/measurements/**", "/api/series/**").hasRole("ADMIN")
                    .requestMatchers(HttpMethod.DELETE, "/api/measurements/**", "/api/series/**").hasRole("ADMIN")
                    .requestMatchers(HttpMethod.POST, "/api/auth/change-password").authenticated()
                    .anyRequest().authenticated()
            )
            .authenticationProvider(authenticationProvider())
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

    return http.build();
}

Metoda filter chain odpowiada za konfigurację dostępności endpointów serwera w zależności od uwierzytelnienia i posiadanej roli użytkownika.

Hasło
W przypadku zmiany hasła dodano wymagania
- musi mieć od 8 do 100 znaków.
- musi zawierać przynajmniej jedną wielką literę, jedną małą literę, jedną cyfrę
@NotBlank(message = "New password is required")
@Size(min = 8, max = 100, message = "Password must be between 8 and 100 characters")
@Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).+$",
        message = "Password must contain at least one uppercase letter, one lowercase letter, and one digit")
private String newPassword;

- musi być różne od obecnego hasła
@Transactional
public void changePassword(String username, ChangePasswordRequest request) {
    User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));

    if (!passwordEncoder.matches(request.getCurrentPassword(), user.getPasswordHash())) {
        throw new BadCredentialsException("Current password is incorrect");
    }

    user.setPasswordHash(passwordEncoder.encode(request.getNewPassword()));
    userRepository.save(user);
}

Hasło nie jest przechowywane jawnym tekstem w bazie danych ze względu na bezpieczeństwo. Hasła są haszowane przy użyciu funkcji BCrypt.

Endpointy
Ekspozycja endpointów zrealizowana została zgodnie z przyjętym standardem Spring WebMVC. Endpointy zdefiniowane są w klasach kontrolerów:
AuthController – logowanie, zmiana hasła
MeasurementController – obsługa pomiarów
SeriesController – obsługa serii pomiarów

Dokładny opis API endpointów w dalszej części dokumentacji.

Komunikacja z bazą danych
Relacyjna struktura danych aplikacji ma swoje odpowiedniki w aplikacji w postaci klas Entity. Wykorzystywane encje to:
Measurement (tabela MEASUREMENT)
Role (tabela ROLE)
Series (tabela SERIES)
User (tabela USER)
Zgodnie ze specyfikacją JPA (konkretna implementacja używana w aplikacji to Hibernate) operacje delegowane są z aplikacji do bazy danych poprzez klasy Repository, które rozszerzają klasę bazową org.springframework.data.jpa.repository.JpaRepository.
Repozytoria:
MeasurementRepository – operacje na pomiarach
@Repository
public interface MeasurementRepository extends JpaRepository<Measurement, Integer> {

    @EntityGraph(attributePaths = {"series", "createdBy"})
    @Override
    Optional<Measurement> findById(Integer id);

    @EntityGraph(attributePaths = {"series", "createdBy"})
    @Override
    List<Measurement> findAll();

    @EntityGraph(attributePaths = {"series", "createdBy"})
    List<Measurement> findBySeriesId(Integer seriesId);

    @EntityGraph(attributePaths = {"series", "createdBy"})
    List<Measurement> findByCreatedById(Integer userId);
}

SeriesRepository – operacje na seriach pomiarów
@Repository
public interface SeriesRepository extends JpaRepository<Series, Integer> {

    @EntityGraph(attributePaths = {"createdBy"})
    @Override
    Optional<Series> findById(Integer id);

    @EntityGraph(attributePaths = {"createdBy"})
    @Override
    List<Series> findAll();

    List<Series> findByCreatedById(Integer userId);
}

UserRepository – operacje na użytkownikach
@Repository
public interface UserRepository extends JpaRepository<User, Integer> {
    Optional<User> findByUsername(String username);
}

Logika biznesowa
Tzw. logika biznesowa zaimplementowana jest na poziomie serwisów, specjalnie wydzielonej warstwy aplikacji do realizacji domenowych założeń. Serwisy spajają warstwę kontrolerów z warstwą komunikacji z bazą danych.
Serwisy:
AuthService
CustomUserDetailsService
MeasurementService
SeriesService
Dodając serię pomiarów można dla niej zdefiniować dopuszczalny zakres temperatur. Następnie dodając i edytując pomiary są one sprawdzane, czy mieszczą się w zadanym przedziale.
/**
 * Validates that a measurement value falls within the series' allowed range.
 * If the series has no min/max bounds (null), no validation is performed.
 * Boundary values are inclusive (value can equal min or max).
 *
 * @param value the measurement value to validate (must not be null)
 * @param series the series containing min/max bounds
 * @throws ValidationException if value is null or outside the series bounds
 */
private void validateMeasurementValue(BigDecimal value, Series series) {
    if (value == null) {
        throw new ValidationException("Measurement value cannot be null");
    }

    BigDecimal minValue = series.getMinValue();
    BigDecimal maxValue = series.getMaxValue();

    // Allow values equal to min/max boundaries (inclusive range)
    if (minValue != null && value.compareTo(minValue) < 0) {
        throw new ValidationException(
            String.format("Measurement value %s is below the minimum allowed value %s for series '%s'",
                value, minValue, series.getName())
        );
    }

    if (maxValue != null && value.compareTo(maxValue) > 0) {
        throw new ValidationException(
            String.format("Measurement value %s exceeds the maximum allowed value %s for series '%s'",
                value, maxValue, series.getName())
        );
    }
}

